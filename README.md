Abstract
========

Disruption Tolerant Networks (DTNs) are employed in applications where
the network is likely to be disrupted due to environmental conditions or
where the network topology makes it impossible to find a direct route
from the sender to the receiver. DTNs are good candidates for situations
where successfully delivering the message is more important than low
delivery times and high network throughput.

Underwater networks typically use acoustic waves for transmitting data.
However, these waves are susceptible to interference from sources of
noise such as the wake from ships, sounds from snapping shrimp, and
collisions from acoustic waves generated by other nodes. DTNs can help
improve the chances of a message being successfully delivered, making
them a good fit for underwater networks.

Introduction
============

Unlike conventional network protocols which rely on end-to-end
connectivity at a given instant of time, DTNs do *not* require a
complete path from the source to the destination when transmitting the
message.

To accomplish this, all types of DTN protocols employ a type of
Store-Carry-And-Forward (SCAF) mechanism to store the message until it
can be sent to the destination. The message can either be sent directly
to the destination or via another node in multi-hop routing.

Some DTN routing algorithms use packet replication to send datagrams to
the destination. This approach might be sub-optimal for underwater
networks which are constrained by transmission power limitations and
suffer from packet collisions when the network is flooded with messages.
Therefore, an implementation of DTNs for UnetStack MAY NOT use packet
replication.

A hypothetical Unet Link agent supporting the DTN protocol described in
this document is referred to as `DtnLink`.

Use Cases
---------

-   **Data Muling**: UnetStack is used on sensor nodes for collecting
    sensor measurements from parts of the ocean. The sensor stores the
    data until a diver can retrieve the sensor. This is a labour
    intensive procedure. To supplant this, `DtnLink` can be used for
    sending the sensor’s data to an AUV when it comes in range of the
    sensor.

-   **Time Varying Links**: A concern in underwater networks is that
    certain links are only available under certain conditions. For
    example, high bandwidth optical links are short-ranged and require a
    Line of Sight to the destination for communication. Ideally,
    `DtnLink` should be able to choose the most optimal link
    depending on the link’s availability and bitrate.

-   **USB Link**: `DtnLink` will maintain a list of pending messages
    in the node’s non-volatile storage. As a potential alternative to
    sending these messages wirelessly, a USB Link agent could work in
    conjunction with `DtnLink` for automatically copying these
    messages to an external storage device.

-   **NUSwan**: The *NUSwan* is a water surface dwelling robot which
    autonomously collects data about the water quality in Singapore’s
    reservoirs with its sensors. This data is relayed to the cloud using
    an LTE connection. However, in large reservoirs, the LTE connection
    may be temporarily unavailable due to lack of coverage.
    `DtnLink` can store pending messages and then send these
    messages when the LTE link is available.

Required Functionality
======================

Node Advertisement Messages (Beacons)
-------------------------------------

As previously mentioned, underwater communication is adversely affected
by packet collisions. Hence, a pending message should only be sent when
the sender is within communication range of another node to avoid
flooding the network with messages which cannot reach the destination.
To accomplish this, `DtnLink` SHOULD periodically send an empty
datagram message at a set interval to advertise its existence to nearby
nodes (a so-called “Beacon” message). On receiving this Beacon message,
a node can start sending datagrams to the Beacon’s sender.

UnetStack nodes also have the capability to *snoop* on the messages
destined for other nodes sharing the same physical medium for
communication. This capability is used for discovery of other nodes
without having to send an explicit Beacon message. Additionally,
`DtnLink` SHOULD NOT send an additional Beacon message if it has
sent a datagram on a particular link in that time period.

`DtnLink` MUST support the capability to store datagrams on the
non-volatile storage of nodes until it can be sent to the destination.
It MUST also delete datagrams whose TTL has expired.

Note that the working of this Beacon functionality is under the
assumption that the connectivity of the links is symmetric. That is, if
Node A can receive a transmission from Node B, Node B is also able to
receive a transmission from Node A. However, this assumption may not be
valid for certain underwater applications.

Unet Capabilities
-----------------

`DtnLink` MUST advertise support for the `LINK` and
`DATAGRAM` service. Along with this, `DtnLink` MAY offer
additional capabilities for `FRAGMENTATION` and `RELIABILITY`
(guaranteed `DatagramDeliveryNtf/DatagramFailureNtf`). Multi-hop
`ROUTING` MAY be offered by `DtnLink` or handled by the Router
agent.

`$1` sent to `DtnLink` MUST have a non-zero TTL value,
or they will be refused at the outset.

Features
--------

`DtnLink` aims to be a drop-in addition to Unet
containers for adding disruption tolerant communication support.
Depending on the implementation, it may support some or all of the
following features.

-   **Storage**: `DtnLink` MUST store datagrams on the node’s
    non-volatile storage until the datagram can be sent to the
    destination.

-   **TTL**: Datagrams saved to the node’s non-volatile storage MUST be
    deleted when the TTL of the datagram is exceeded. TTL information
    for a datagram MUST be propagated through the network. `DtnLink`
    SHOULD do so by encapsulating a datagram in its own PDU as described
    in the PDU Section.

-   **Reliability**: `DtnLink` only uses Link agents supporting
    reliability for sending messages. Hence, we are guaranteed to know
    if a datagram has failed or has been successfully delivered.
    `DtnLink` SHOULD forward a `DatagramDeliveryNtf` to the
    requesting application. On the other hand, if a datagram times out,
    `DtnLink` SHOULD send a `$1` to the
    application.

-   **Beacons**: As explained previously, `DtnLink`
    SHOULD periodically send empty datagrams (Beacons) on all its
    underlying Link agents for alerting other nodes about its presence.
    On receiving a Beacon, a node can start sending datagrams residing
    in its non-volatile storage to that node.

-   **Multiple Links**: A particular node may have multiple available
    Link agents. `DtnLink` SHOULD populate a list of all the Link
    agents which support reliability. `DtnLink` MAY also
    automatically switching between links depending on whether they have
    a connection to the next hop for a datagram.

-   **Fragmentation**: Datagrams which exceed the MTU of the underlying
    links MAY be split by `DtnLink` into smaller fragments which are
    sent like regular datagrams. If the implementation supports
    fragmentation, the receiving instance of `DtnLink` MUST wait for
    the reception of all of these fragments before reassembling the
    original message. Fragments MUST be encoded in the `DtnLink’s`
    PDU format.

-   **Randomised Sending**: While a very rare issue in real-world
    deployments, datagrams sent at exactly the same time can result in
    collisions in simulations. Hence, `DtnLink` MAY delay sending
    datagrams by a random amount of time.

-   **Stop-And-Wait Sending**: To avoid overtaxing the network,
    `DtnLink` MAY adopt the strategy of only sending one datagram at
    a time and waiting for a notification about its receipt before
    sending the next one.

-   **Short-circuit Sending**: As implemented by the newer Unet3 agents,
    `DtnLink` MAY support short-circuiting datagrams on single-hop
    routes by sending the datagram without its PDU headers. This reduces
    the message size. Regardless, datagrams exceeding the MTU will still
    need to be encoded in PDUs to be reassembled at the receiver’s
    instance of `DtnLink`.

PDU Structure
-------------

`DtnLink` encodes the data from datagrams by appending
its own header. The structure of this header, in order, is as follows:

-   24-bit TTL, representing the lifetime of the datagram in seconds.

-   8-bit Protocol number of the original datagram.

-   1-bit To Be Continued (TBC) bit, for informing the receiver if more
    datagrams are expected.

-   8-bit Payload ID, for uniquely identifying large messages by the
    tuple of their sender and the Payload ID.

-   23-bit Starting pointer, for informing the receiver about where to
    insert the contents of a fragment into its payload file.

For datagrams which do not need to be fragmented, the 32 bits following
the Protocol number are all set to 0.

Multi-hop Routing
=================

For multi-hop routing, `DtnLink` MAY rely on the Router agent to
send the datagrams to the final destination. A sequence diagram of what
this looks like is shown below:

![Multi-Hop Message
Sending](https://i.imgur.com/8KlWc2q.png)

In such a case, `DtnLink` MUST encode data in a PDU to preserve the
datagrams TTL information throughout.

Changes Required in UnetStack
=============================

As shown in Figure \[mhd\], the `$1` on the intermediate
node (Node 2) first passes through the `DtnLink` for decoding. Once
decoded, the `DtnLink` emits a `DatagramNtf` for the Router
which takes the datagram, consults its routing tables, and then passes
the datagram down to `DtnLink` for sending to the next node.
However, UnetStack requires some changes to implement this behaviour:

-   **Feature**: `DatagramNtf` MUST have a TTL field for the
    forwarding of the datagram from the `DtnLink` to the Router.
    This TTL from the `DatagramNtf` MUST be copied to the
    `DatagramReq` which the Node 2 Router sends to its own
    `DtnLink`.

-   **Feature**: The Router SHOULD have a preference for routing
    `DatagramNtf / DatagramReq` with a set TTL value via disruption
    tolerant links. **NOTE:** For this to work, we need to have a way of
    identifying what a Disruption Tolerant Link is! Maybe `DtnLink`
    can expose such a Parameter and the Router can look for that?

-   **Feature**: Link agents should have a `dataRate` property so
    the `DtnLink` can set the priority of its underlying Links
    accordingly.

-   **Bugfix**: `UdpLink` does not currently work in Unet3 as
    mentioned in this GitHub
    [issue](https://github.com/org-arl/unet-contrib/issues/17). This is
    required for testing the NUSwan simulation scenario.

Appendix - DtnLink Prototype
============================

Automated Regression Testing
----------------------------

`DtnLink` can be tested reproducibly. As new features are added to
the agent, it is imperative that a basic subset of its functionality
remains intact. These tests check that the key features of `DtnLink`
are working correctly.

As the `DtnLink` will work in conjunction with several other agents,
it is more useful to see the output of the agent on certain inputs
rather than diving into the implementation of how each function
performs. This is formally called “Black-box” testing.

![Black-box
testing](https://i.imgur.com/645EAMa.png)

The above figure is a simple example of the key concept of the
black-box. The internals can be totally abstracted for the tests as we
only wish to see the outputs of the black-box on certain inputs. In
these tests, the `DtnLink` is the black-box and the specially
developed `TestApp` and `TestLink` agents test the behaviour of
the `DtnLink`. More specifically, the `TestApp` prepares
`DatagramReqs` for sending to the `DtnLink` and the
`TestLink` checks the receipt of these datagrams, and send the
corresponding `Ntfs` to the `DtnLink`.

By these means, we can “trick” the `DtnLink` into behaving as it
would in a multi node simulation. The following tests are conducted with
this test suite:

-   `TRIVIAL_MESSAGE`: This test sends an empty `DatagramReq` to
    `DtnLink` to check if the agent correctly accepts messages with
    TTLs encoded.

-   `SUCCESSFUL_DELIVERY`: This test sends a `DatagramReq` with
    the USER protocol number to check if the datagram sent to the
    underlying link is sent without the `DtnLink` headers and can be
    short-circuited. It also checks whether the `DatagramReq` is
    formatted correctly and has the original Protocol number.

-   `ROUTER_MESSAGE`: This test sends a `DatagramReq` with the
    `ROUTING` protocol number to check if the datagram sent to the
    underlying link is encoded correctly with the `DTNL-PDU` scheme
    and has its TTL adjusted accordingly.

-   `BAD_MESSAGE`: This test checks if the `DtnLink` responds
    with a `Performative.REFUSE` when it receives a
    `DatagramReq` without a set TTL value.

-   `EXPIRY_PRIORITY`: This test checks if the datagrams sent to
    `DtnLink` in `EXPIRY_PRIORITY` mode from `TestApp` are
    forwarded to the `TestLink` in order ascending order of their
    TTL values.

-   `ARRIVAL_PRIORITY`: This test checks if the datagrams sent to
    `DtnLink` in `ARRIVAL_PRIORITY` mode from `TestApp` are
    forwarded to the `TestLink` in order ascending order of their
    arrival times.

-   `RANDOM_PRIORITY`: This test checks if the datagrams sent to
    `DtnLink` in `RANDOM_PRIORITY` mode from `TestApp` are
    forwarded to the `TestLink` in random order without regards to
    the TTL values or arrival time.

-   `LINK_TIMEOUT`: This test checks if `DtnLink` correctly
    disables sending messages on links which have not sent a message for
    a certain period of time.

-   `MULTI_LINK`: This test checks if `DtnLink` correctly uses
    the priority of Links set through a `ParameterReq` to change the
    priority of the links used to communicate with other nodes.

-   `PAYLOAD_MESSAGE`: This test checks if the `DtnLink` is
    capable of correctly fragmenting a large datagram into smaller
    fragments to fit in the underlying link’s MTU. These fragments are
    sent to another instance of `DtnLink` to check if they fragments
    can be successfully reassembled to form the original datagram.

Configurable Options
--------------------

`DtnLink` is highly configurable and the following Parameters can be
adjusted depending to the use-case:

-   **Periodic Functions**: The `beaconTimeout` (maximum time of the
    link being idle before sending a Beacon message), `GCPeriod`
    (time period of deleting expired and delivered datagrams from
    non-volatile storage), `datagramResetPeriod` (time period of
    sending datagrams), and `linkExpiryTime` (time for which a link
    can remain idle without removing it from the active links list)
    parameters can be set at runtime.

-   **Datagram Priority**: Datagrams can be sent according to their
    order of `ARRIVAL`, ascending order of `EXPIRY` times, and
    in a `RANDOM` manner. These options are exposed in the
    `datagramPriority` parameter.

-   **Link Priority**: The order in which underlying links are used by
    `DtnLink` can be changed by sending a list of the AgentIDs to
    `linkPriority`. If these AgentIDs are `null` or not
    registered by the `DtnLink`, the request will be ignored.

Limitations
-----------

`DtnLink` suffers from some design limitations which may be
revisited in the future:

-   The Stop-And-Wait sending approach of the `DtnLink` is simple
    and effective, but it can negatively impact network throughput
    because it waits for the result of sending the datagram before
    sending the next one.

-   In the unlikely case that a node runs out of free space on the
    non-volatile storage when receiving a datagram en-route to another
    node via a multi-hop path, the `DDN` for that datagram will be
    sent to the immediate sender of the datagram but the datagram will
    not be saved on the node’s non-volatile storage. The datagram will
    be lost in transit despite the sender thinking the outbound datagram
    was successfully delivered.

    Even if the `DtnLink` is able to send a `DFN` for the same,
    its underlying link would have already sent a `DDN` for that
    datagram. Furthermore, the `DtnLink` does not know which
    protocol number the sending app listens to.

-   The TTL of a datagram is only decremented when it leaves the sending
    node. Therefore, the propagation delay is not accounted for in the
    TTL.

-   Expired and deleted datagrams are deleted en masse using a
    `TickerBehavior`, rather than deleting these datagrams as soon
    as possible. This delayed behaviour of solution can be an issue in
    nodes with limited non-volatile storage. However, datagrams are
    checked for whether they have expired or have already been delivered
    before sending to another node.
